# Лабораторная работа на тему  «Визуализация движения объектов по графу»

## Основные классы

- MasterMind – запускающий процесс генерации всех остальный объектов и единственный объект для размещения на уровне.
- Nodes – класс, генерирующий все вершины графа и запускающий генерацию ребер, движущихся объектов.
- Links – класс ребер графа.
- Runners – класс движущихся объектов, контролирует их правильное перемещение по графу и запускает генерацию стрелок-направлений пути.  
- Arrow – класс стрелок, указывающих направление пути движущихся объектов.
  
## Алгоритм построения графа

Для генерации связанного графа был использован модифицированный алгоритм генерации лабиринта поиском в глубину.

Алгоритм начинает с выбора произвольной стартовой ячейки в лабиринте. Затем он переходит к соседней ячейке, которая еще не была посещена, и отмечает ее как посещенную. После этого алгоритм рекурсивно продолжает этот процесс, пока все доступные ячейки не будут посещены.

Когда алгоритм доходит до ячейки, которая уже была посещена, он возвращается к предыдущей ячейке, чтобы найти новые не посещенные ячейки, и продолжает построение лабиринта, пока не будут посещены все ячейки. В конечном итоге это приводит к созданию готового лабиринта.

Алгоритм генерации лабиринта поиском в глубину может быть легко модифицирован для создания связанного графа. В основе модификации лежит идея замены каждой стены в лабиринте на ребро графа, которое соединяет две соседние комнаты. 

После реализации алгоритма генерации лабиринта поиском в глубину полученный граф будет являтся деревом. Чтобы усложнить его, к массиву существующих ребер были добавлены дополнительные ребра случайным образом, количество которых зависит от размера графа.

## Алгоритм движения объектов по графу

Для нахождения кратчайшего пути в графе для движения объектов используется алгоритм Дейкстры.

Каждой вершине из списка вершин ставится в соответствие метка — минимальное известное расстояние от этой вершины до конечной вершины.

Алгоритм работает пошагово — на каждом шаге он «посещает» одну вершину и пытается уменьшать метки. Работа алгоритма завершается, когда все вершины посещены.

Метка конечной вершины полагается равной 0, метки остальных вершин — бесконечности. Это отражает то, что расстояния от конечной вершины до других вершин пока неизвестны. Все вершины графа помечаются как непосещенные.

Если все вершины посещены, алгоритм завершается. В противном случае, из ещё не посещённых вершин выбирается вершина, имеющая минимальную метку. Рассматриваются все возможные маршруты, в которых эта вершина является предпоследним пунктом. Вершины, в которые ведут ребра из выбранной вершины, называются соседями этой вершины. Для каждого соседа вершины, кроме отмеченных как посещённые, рассматривается новая длина пути, равную сумме значений текущей метки выбранной вершины и длины ребра, соединяющего ее с этим соседом. Если полученное значение длины меньше значения метки соседа, заменяется значение метки полученным значением длины. Рассмотрев всех соседей, пометим выбранную вершину как посещенную и повторим шаг алгоритма.
